/*
ЮФУ, ИКТИБ, МОП ЭВМ
ПИОТА2
Индивидуальное задание. Вариант 25.1
КТбо2-6, Миронов Егор Сергеевич
16.10.2024
*/

#include <iostream>
#include <map>
#include <deque>
#include <utility>
#include <fstream>
#include <set>
#include <windows.h>
#include <vector>
#include <string>

using namespace std;

//Функция для смены цвета в консоли для отображения головки МТ
void setColor(int color) {
    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    SetConsoleTextAttribute(hConsole, color);
}

typedef struct Transition {
    string lenta; // Лента машины Тьюринга
    string nowCondition; // Текущее состояние
    int indexForNowSym; // Положение головки
    bool isWorking; //Флаг для отображения заключительного состояния
    map<pair <string, char>, tuple <char, char, string>> commands; // Структура для хранения таблицы переходов
    set<char> Alphabet_input = { 'a', 'b', 'c' }; //Множество входных символов
    set<string> endConditions = { "q0" }; //Множество заключительных состояний
} Transition;

Transition Turing;

//Функция для инициализации таблицы переходов
int init() {
    ifstream inputFile("TXT_FOR_PIOTA.txt");
    vector <char> vec = { 'a', 'b', 'c', 'd', 'e', 'f', '#' , '*', '1', '!' };
    if (!inputFile) {
        return 0;
    }
    else {
        for (int i = 0; i < 30; i++) {
            for (int j = 0; j < 10; j++) {
                char s1, s2;
                string s3;
                inputFile >> s1;
                if (s1 == 'n') {
                    continue;
                }
                inputFile >> s2 >>  s3;
                auto para = make_pair("q" + to_string(i), vec[j]);
                Turing.commands[para] = { s1, s2, s3 };
            }
        }
    }
}

//Функция для вывода ленты и текущего состояния МТ
void print() {
	for (size_t i = 0; i < Turing.indexForNowSym; i++) {
		cout << Turing.lenta[i];
	}
	setColor(4);
	cout << Turing.lenta[Turing.indexForNowSym];
	setColor(7);
	for (size_t i = Turing.indexForNowSym + 1; i < Turing.lenta.length(); i++) {
		cout << Turing.lenta[i];
	}
    cout << ' ' << Turing.nowCondition << endl;
}

//Функция, которая ищет команду по текущему символу и состоянию
auto findCommand() {
    pair <string, char> key = make_pair(Turing.nowCondition, Turing.lenta[Turing.indexForNowSym]);
    auto it = Turing.commands.find(key);
    if (it != Turing.commands.end()) {
        return it->second;
    }
    else {
        tuple<char, char, string> NO_COMMAND = { ' ', ' ', "NO_COMMAND" };
        return NO_COMMAND;
    }
}

//Функция для добавления пробелов слева и справа
void addEmptySymbols() {
    if (Turing.lenta[0] != '!') {
        Turing.lenta = '!' + Turing.lenta;
    }
    if (Turing.lenta.back() != '!') {
        Turing.lenta += '!';
    }
}

//Функция для перемещения головки МТ
void movePtr(char direction) {
    if (direction == '>') {
        Turing.indexForNowSym++;
    }
    else {
        Turing.indexForNowSym--;
    }
}

//Функция, реализующая один шаг работы МТ
bool turingStep() {
    auto it = findCommand();
    if (get<2>(it) == "NO_COMMAND") {
        return true;
    }
    char firstElemInTuple = get<0>(it);
    char secondElemInTuple = get<1>(it);
    string thirdElemInTuple = get<2>(it);
    Turing.lenta[Turing.indexForNowSym] = firstElemInTuple;
    Turing.nowCondition = thirdElemInTuple;
    movePtr(secondElemInTuple);
    if (Turing.endConditions.count(Turing.nowCondition)) {
        Turing.isWorking = false;
    }
    return false;

}

//Функция, реализующая работу МТ
int turing(string chain) {
    int count = 0;
    bool flagForNoCommand = false;
    Turing.isWorking = true;
    Turing.indexForNowSym = 1;
    Turing.nowCondition = "q1";
    Turing.lenta = chain;

    while (Turing.isWorking and count < 10001 and !flagForNoCommand) {
        addEmptySymbols();
        print();
        flagForNoCommand = turingStep();
        count++;
    }
    if (flagForNoCommand) {
        return 1;
    }
    else if (count > 10001) {
        return 2;
    }
    else {
        cout << "Ответ: ";
        print();
        return 0;
    }
}

//Функция для проверки правильности входной цепочки
bool checkInputString(string chain) {
    for (auto sym : chain) {
        if (!Turing.Alphabet_input.count(sym)) {
            return 0;
        }
    }
    return 1;
}

int main() {
    setlocale(LC_ALL, "ru");

    int flag = 0;
    bool flagForMainWhile = true;
    string chain; // Цепочка, введенная пользователем
 
    flag = init();
    if (!flag) {
        cout << "Файл не удалось открыть. Проверьте название и расширение" << endl;
        flagForMainWhile = 0;
    }
    else {
        cout << "Файл был успешно открыт" << endl;
    }

    while (flagForMainWhile) {
        cout << "Введите цепочку, состоящую из букв a, b, c: ";
        cin >> chain;
        flag = checkInputString(chain);
        if (flag) {
            cout << "Цепочка была введена корректно" << endl;
            flag = turing(chain);
            if (flag == 1) {
                cout << "Ошибка во время работы машины Тьюринга" << endl;
                cout << "Отсутствует команда для текущей конфигурации" << endl;
            }
            else if (flag == 2) {
                cout << "Превышено максимальное количество шагов(10000)" << endl;
            }
        }
        else {
            cout << "Цепочка некорректна!" << endl;
            cout << "Убедитесь, что цепочка состоит только из букв a, b, c" << endl;
        }
        cout << "Хотите ввести данные еще раз? 1/0: ";
        cin >> flagForMainWhile;
    }
    return 0;
}
